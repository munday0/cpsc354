\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Stephanie Munday  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Short  summary of purpose and content.  
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

This is the report for CPSC 354 Programming Languages. It will contain homework for each week, as well as project work and analysis.


\section{Homework}\label{homework}

This section will contain your solutions to homework. 

\subsection{Week 1}

HW 1 - Greatest Common Divisor

\begin{lstlisting}
def gcd(n, m):
    while  n != m:
        if  n > m:
            n = n-m
        else:
            m = m-n
    return n 
\end{lstlisting}
%
The code above implements Euclid's algorithm to find the greatest common divisor in python. Below is an explanation given sample input gcd(9,33).

\medskip\noindent
While n != m, the code will compare whether or not n is greater than m. If n \textgreater{} m, n will become n -- m. Otherwise if n \textless{} m, m will become m -- n. When n == m, the greatest common divisor has been found.

\medskip\noindent
Keeping this logic in mind, let n = 9, m = 33.

\begin{lstlisting}
  gcd(9,33) =
  gcd(9,24) =
  gcd(9,15) =
  gcd(9,6) =
  gcd(3,6) =
  gcd(3,3) =
  3
  \end{lstlisting}
  %

\medskip\noindent
Since n == m and the value of both is 3, the greatest common divisor is 3 for this example.


\subsection{Week 2}

HW 2 - Recursion in Functional Programming

\begin{lstlisting}
select_evens :: [a] -> [a]
select_evens [] = []
select_evens (x:(y:xs)) = y:select_evens(xs)

select_odds :: [a] -> [a]
select_odds [] = []
select_odds (x:(y:xs)) = x:select_odds(xs)

member :: (Eq a) => a -> [a] -> Bool
member a [] = False
member a (x:xs)
    | a == x = True
    | otherwise = a `member` xs

append :: (Ord a) => [a] -> [a] -> [a]
append [] [] = []
append [] ys = ys
append (x:xs) (ys) = x:append(xs) (ys)

revert :: [a] -> [a]
revert [] = []
revert (x:xs) = append (revert xs) [x]

less_equal :: (Ord a) => [a] -> [a] -> Bool
less_equal [] [] = True
less_equal (x:xs) (y:ys)
    | x > y    = False
    | otherwise = xs `less_equal` ys
\end{lstlisting}
%

\noindent The code above implements select\_evens, select\_odds, member, append, revert, less\_equal as recursive functions in Haskell. Below are explanations showing computations for given inputs. \newline

\noindent
Select Evens example: 
\newline\newline\indent
Select Evens ["a","b","c","d"]
\begin{lstlisting}
select_evens ["a","b","c","d"] = 
    "b" : (select_evens ["c","d"]) =
    "b" : ("d" : (select_evens [])) =
    ["b","d"]
\end{lstlisting}
%

\noindent
Select Odds example: 
\newline\newline\indent
Select Odds ["a","b","c","d"]
\begin{lstlisting}
select_odds ["a","b","c","d"] = 
    "a" : (select_odds ["c","d"]) =
    "a" : ("c" : (select_odds [])) =
    ["a","c"]
\end{lstlisting}
%

\noindent
Member example: 
\newline\newline\indent
Member 2 [5,2,6]
\begin{lstlisting}
member 2 [5,2,6] = 
    2 != 5 : (member 2 [2,6]) =
    2 != 5 : (2 == 2) =
    True
\end{lstlisting}
%

\noindent
Append example: 
\newline\newline\indent
Append [1,2,3] [4,5]
\begin{lstlisting}
append [1,2,3] [4,5] = 
    1 : (append [2,3] [4,5]) = 
    1 : (2 : (append [3] [4,5])) = 
    1 : (2 : (3 : (append [] [4,5]))) = 
    1 : (2 : (3 : [4,5])) = 
    [1,2,3,4,5]
\end{lstlisting}
%

\noindent
Revert example: 
\newline\newline\indent
Revert [1,2,3]
\begin{lstlisting}
revert [1,2,3] = 
    append(revert [2,3], [1]) =
    append(revert [2,3], [1]) : append(revert [3], [2]) =
    append(revert [2,3], [1]) : append(revert [3], [2]) : append(revert [], [3]) =
    [3,2,1]
\end{lstlisting}
%

\noindent
Less Equal example: 
\newline\newline\indent
Less Equal [1,2,3] [2,3,4]
\begin{lstlisting}
less_equal [1,2,3] [2,3,4] = 
    1 !> 2 : (less_equal [2,3] [3,4]) =
    1 !> 2 : (2 !> 3 : (less_equal [3] [4])) =
    1 !> 2 : (2 !> 3 : (3 !> 4 : (less_equal [] []))) =
    True
\end{lstlisting}
%

\subsection{Week 3}

HW 3 - Towers of Hanoi

\begin{lstlisting}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move 0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move 1 2  
				hanoi 1 0 2 = move 0 2 
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{lstlisting}
%

In order to solve the puzzle, the moves are as follows:
\begin{lstlisting}
move 0 2 
move 0 1
move 2 1 
move 0 2  
move 1 0  
move 1 2  
move 0 2 
move 0 1
move 2 1
move 2 0
move 1 0
move 2 1
move 0 2
move 0 1
move 2 1
move 0 2
move 1 0
move 1 2
move 0 2
move 1 0
move 2 1
move 2 0
move 1 0
move 1 2
move 0 2
move 0 1
move 2 1
move 0 2
move 1 0
move 1 2
move 0 2
\end{lstlisting}
%

\noindent
The word "hanoi" appears in the computation 31 times.
\newline\newline 
This computation can be expressed as a formula that works for moving any number of disks n as:

\begin{lstlisting}
hanoi 1 x y = move x y

hanoi (n+1) x y = 
	hanoi n x (other x y) 
	move x y 
	hanoi n (other x y) y
\end{lstlisting}
%

\subsection{Week 4}

HW 4 - Parsing and Context-Free Grammars

\begin{lstlisting}
Abstract Syntax Tree: 2 + 1
    Plus (Num 2) (Num 1)
\end{lstlisting}
%
\Tree [.Plus [.Num 2 ] [.Num 1 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + 2 * 3
    Plus (Num 1) (Times (Num 2) (Num 3))
\end{lstlisting}
%
\Tree [.Plus [.Num 1 ] [.Times [.Num 2 ] [.Num 3 ]]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + (2 * 3)
    Plus (Num 1) (Times (Num 2) (Num 3))
\end{lstlisting}
%
\Tree [.Plus [.Num 1 ] [.Times [.Num 2 ] [.Num 3 ]]]

\begin{lstlisting}
Abstract Syntax Tree: (1 + 2) * 3
    Times (Plus (Num 1) (Num 2)) (Num 3)
\end{lstlisting}
%
\Tree [.Times [.Plus [.Num 1 ] [.Num 2 ]] [.Num 3 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + 2 * 3 + 4 * 5 + 6
    Plus (Plus (Plus (Num 1) (Times (Num 2) (Num 3))) (Times (Num 4) (Num 5))) (Num 6)
\end{lstlisting}
%
\Tree [.Plus [.Plus [.Plus [.Num 1 ] [.Times [.Num 2 ] [.Num 3 ]]] [.Times [.Num 4 ] [.Num 5 ]]] [.Num 6 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + 2 + 3
    Plus (Plus (Num 1) (Num 2)) (Num 3)
\end{lstlisting}
%
\Tree [.Plus [.Plus [.Num 1 ] [.Num 2 ]] [.Num 3 ]]

\begin{lstlisting}
Abstract Syntax Tree: (1 + 2) + 3
    Plus (Plus (Num 1) (Num 2)) (Num 3)
\end{lstlisting}
%
\Tree [.Plus [.Plus [.Num 1 ] [.Num 2 ]] [.Num 3 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + (2 + 3)
    Plus (Num 1) (Plus (Num 2) (Num 3))
\end{lstlisting}
%
\Tree [.Plus [.Num 1 ] [.Plus [.Num 2 ] [.Num 3 ]]]

\begin{lstlisting}
The abstract syntax tree of 1+2+3 is identical to the one of (1+2)+3, but not the one of 1+(2+3).
\end{lstlisting}
%

\subsection{Week 5}

HW 5 - Syntax + Semantics of Lambda Calculus
Syntax
\begin{lstlisting}
x = EVar (Id "x")
\end{lstlisting}
%
\Tree [.EVar [.Id x ]]

\begin{lstlisting}
x x = EApp (EVar (Id "x") EVar (Id "x"))
\end{lstlisting}
%
\Tree [.EApp [.EVar [.Id x ] [.EVar [.Id x ]]]]

\begin{lstlisting}
x y = EApp (EVar (Id "x") EVar (Id "y"))
\end{lstlisting}
%
\Tree [.EApp [.EVar [.Id x ] [.EVar [.Id y ]]]]

\begin{lstlisting}
x y z = EApp (EVar (Id "x") EVar (Id "y")) EVar (Id "z"))
\end{lstlisting}
%
\Tree [.EApp [.EVar [.Id x ] [.EVar [.Id y ]]][.EVar [.Id z ]]]

\begin{lstlisting}
\ x.x = Prog (EAbs(Id "x" EVar(Id "x")))
\end{lstlisting}
%
\Tree [.Prog [.EAbs [.Id x ] [.EVar [.Id x ]]]]

\begin{lstlisting}
(\x.x) x = Prog(EApp(EAbs(Id "x" EVar(Id "x")) EVar(Id "x")))
\end{lstlisting}
%
\Tree [.Prog [.EApp [.EAbs [.Id x ] [.EVar [.Id x ]]]] [.EVar [.Id x ]]]

\begin{lstlisting}
(\ x . (\ y . x y)) (\ x.x) z = Prog(EApp(EApp(EAbs(Id "x", EAbs(Id "y", EApp(EVar(Id "x"), EVar(Id "y")))), EAbs(Id "x", EVar(Id "x"))), EVar(Id "z")))
\end{lstlisting}
%
\Tree [.Prog [.EApp [.EApp [.EAbs [.Id x ] [.EAbs [.Id y ] [.EApp [.EVar [.Id x ]] [.EVar [.Id y ]]]]] [.EAbs [.Id x ] [.EVar [.Id x ]]]] [.EVar [.Id z ]]]]

\begin{lstlisting}
(\ x . \ y . x y z) a b c = Prog(EApp(EApp(EAbs(Id "x", EAbs(Id "y", EApp(EApp(EVar(Id "x"), EVar(Id "y")), EVar(Id "z")))), EVar(Id "a")), EVar(Id "b")))
\end{lstlisting}
%
\Tree  [.Prog [.EApp [.EApp [.EAbs [.Id x ] [.EAbs [.Id y ] [.EApp [.EApp [.EVar [.Id x ]] [.EVar [.Id y ]]] [.EVar [.Id z ]]]]] [.EVar [.Id a ]]] [.EVar [.Id b ]]]]

Semantics
\begin{lstlisting}
- Evaluate using pen-and-paper the following expressions:

(\x.x) a = a

\x.x a = \x.x a

(\x.\y.x) a b = (\y.a) b = a

(\x.\y.y) a b = (\y.y) b = b

(\x.\y.x) a b c = (\y.a) b c = a c

(\x.\y.y) a b c = (\y.y) b c = b c

(\x.\y.x) a (b c) = (\y.a) (b c) = a

(\x.\y.y) a (b c) = (\y.y) (b c) = b c

(\x.\y.x) (a b) c = (\y.a b) c = a b

(\x.\y.y) (a b) c = (\y.y) c = c

(\x.\y.x) (a b c) = \y.a b c

(\x.\y.y) (a b c) = \y.y

- Evaluate (\x.x)((\y.y)a) by executing the function evalCBN

evalCBN(EApp (EAbs (Id "x") (EVar (Id "x"))) (EApp (EAbs (Id "y") (EVar (Id "y"))) (EVar (Id "a")))) = 
evalCBN (EApp (EAbs (Id "x") (EVar (Id "x"))) subst (Id "y") (EVar (Id "a")) (EVar (Id "y"))) =
evalCBN (EApp (EAbs (Id "x") (EVar (Id "x"))) EVar (Id "a")) =
evalCBN (subst (Id "x") (EVar (Id "a")) (EVar (Id "x"))) =
evalCBN (EVar (Id "a")) =
EVar (Id "a")
\end{lstlisting}
%


\section{Project}

Introductory remarks ...

The following structure should be suitable for most practical projects. 

\subsection{Specification}
\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

(approx 400 words)

In the conclusion, I want a critical reflection on the content of the course. Step back from the technical details. How does the course fit into the wider world of programming languages and software engineering?

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\bibitem[P]{P} \href{https://tex.stackexchange.com/questions/2369/why-do-the-less-than-symbol-and-the-greater-than-symbol-appear-wrong-as}{Punctuation}, StackExchange, 2022.
\bibitem[S]{S} \href{https://tex.stackexchange.com/questions/14526/spaces-behind-textgreater-not-working-as-expected}{Spacing}, StackExchange, 2022.
\bibitem[T]{T} \href{http://sznfong.scripts.mit.edu/site/wp-content/uploads/2018/03/treedrawingtutorialv2.pdf}{Trees}, Massachusetts Institute of Technology, 2022.
\end{thebibliography}

\end{document}
