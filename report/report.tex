\documentclass{article}

\usepackage{qtree}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Stephanie Munday  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Short  summary of purpose and content.  
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

This is the report for CPSC 354 Programming Languages. It will contain homework for each week, as well as project work and analysis.


\section{Homework}\label{homework}

This section will contain your solutions to homework. 

\subsection{Week 1}

HW 1 - Greatest Common Divisor

\begin{lstlisting}
def gcd(n, m):
    while  n != m:
        if  n > m:
            n = n-m
        else:
            m = m-n
    return n 
\end{lstlisting}
%
The code above implements Euclid's algorithm to find the greatest common divisor in python. Below is an explanation given sample input gcd(9,33).

\medskip\noindent
While n != m, the code will compare whether or not n is greater than m. If n \textgreater{} m, n will become n -- m. Otherwise if n \textless{} m, m will become m -- n. When n == m, the greatest common divisor has been found.

\medskip\noindent
Keeping this logic in mind, let n = 9, m = 33.

\begin{lstlisting}
gcd(9,33) =
gcd(9,24) =
gcd(9,15) =
gcd(9,6) =
gcd(3,6) =
gcd(3,3) =
3
\end{lstlisting}
%

\medskip\noindent
Since n == m and the value of both is 3, the greatest common divisor is 3 for this example.


\subsection{Week 2}

HW 2 - Recursion in Functional Programming

\begin{lstlisting}
select_evens :: [a] -> [a]
select_evens [] = []
select_evens (x:(y:xs)) = y:select_evens(xs)

select_odds :: [a] -> [a]
select_odds [] = []
select_odds (x:(y:xs)) = x:select_odds(xs)

member :: (Eq a) => a -> [a] -> Bool
member a [] = False
member a (x:xs)
    | a == x = True
    | otherwise = a `member` xs

append :: (Ord a) => [a] -> [a] -> [a]
append [] [] = []
append [] ys = ys
append (x:xs) (ys) = x:append(xs) (ys)

revert :: [a] -> [a]
revert [] = []
revert (x:xs) = append (revert xs) [x]

less_equal :: (Ord a) => [a] -> [a] -> Bool
less_equal [] [] = True
less_equal (x:xs) (y:ys)
    | x > y    = False
    | otherwise = xs `less_equal` ys
\end{lstlisting}
%

\noindent The code above implements select\_evens, select\_odds, member, append, revert, less\_equal as recursive functions in Haskell. Below are explanations showing computations for given inputs. \newline

\noindent
Select Evens example: 
\newline\newline\indent
Select Evens ["a","b","c","d"]
\begin{lstlisting}
select_evens ["a","b","c","d"] = 
    "b" : (select_evens ["c","d"]) =
    "b" : ("d" : (select_evens [])) =
    ["b","d"]
\end{lstlisting}
%

\noindent
Select Odds example: 
\newline\newline\indent
Select Odds ["a","b","c","d"]
\begin{lstlisting}
select_odds ["a","b","c","d"] = 
    "a" : (select_odds ["c","d"]) =
    "a" : ("c" : (select_odds [])) =
    ["a","c"]
\end{lstlisting}
%

\noindent
Member example: 
\newline\newline\indent
Member 2 [5,2,6]
\begin{lstlisting}
member 2 [5,2,6] = 
    member 2 [2,6] =
    True
\end{lstlisting}
%

\noindent
Append example: 
\newline\newline\indent
Append [1,2,3] [4,5]
\begin{lstlisting}
append [1,2,3] [4,5] = 
    1 : (append [2,3] [4,5]) = 
    1 : (2 : (append [3] [4,5])) = 
    1 : (2 : (3 : (append [] [4,5]))) = 
    1 : (2 : (3 : [4,5])) = 
    [1,2,3,4,5]
\end{lstlisting}
%

\noindent
Revert example: 
\newline\newline\indent
Revert [1,2,3]
\begin{lstlisting}
revert [1,2,3] = 
    append(revert [2,3], [1]) =
    append(append (revert [3]) [2]) [1] =
    append(append (append (revert []) [3]) [2]) [1] = 
    append(append (append [] [3]) : [2]) [1] =
    append(append [3] [2]) [1] =
    append 3 : (2) [1] =
    append [3,2] [1] =
    3 : (append [2] [1]) =
    3 : (2 : (append [] [1])) =
    3 : (2 : 1) =
    [3,2,1]
\end{lstlisting}
%

\noindent
Less Equal example: 
\newline\newline\indent
Less Equal [1,2,3] [2,3,4]
\begin{lstlisting}
less_equal [1,2,3] [2,3,4] = 
    less_equal [2,3] [3,4] =
    less_equal [3] [4] =
    True
\end{lstlisting}
%

\subsection{Week 3}

HW 3 - Towers of Hanoi

\begin{lstlisting}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move 0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move 1 2  
				hanoi 1 0 2 = move 0 2 
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{lstlisting}
%

In order to solve the puzzle, the moves are as follows:
\begin{lstlisting}
move 0 2 
move 0 1
move 2 1 
move 0 2  
move 1 0  
move 1 2  
move 0 2 
move 0 1
move 2 1
move 2 0
move 1 0
move 2 1
move 0 2
move 0 1
move 2 1
move 0 2
move 1 0
move 1 2
move 0 2
move 1 0
move 2 1
move 2 0
move 1 0
move 1 2
move 0 2
move 0 1
move 2 1
move 0 2
move 1 0
move 1 2
move 0 2
\end{lstlisting}
%

\noindent
The word "hanoi" appears in the computation 31 times.
\newline\newline 
This computation can be expressed as a formula that works for moving any number of disks n as:

\begin{lstlisting}
hanoi(n+1) x y = hanoi n x(other x y)
move x y
hanoi n(other x y)y
\end{lstlisting}
%



\begin{lstlisting}
hanoi 1 x y = move x y

hanoi (n+1) x y = 
	hanoi n x (other x y) 
	move x y 
	hanoi n (other x y) y
\end{lstlisting}
%

\subsection{Week 4}

HW 4 - Parsing and Context-Free Grammars

\begin{lstlisting}
Abstract Syntax Tree: 2 + 1
    Plus (Num 2) (Num 1)
\end{lstlisting}
%
\Tree [.Plus [.Num 2 ] [.Num 1 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + 2 * 3
    Plus (Num 1) (Times (Num 2) (Num 3))
\end{lstlisting}
%
\Tree [.Plus [.Num 1 ] [.Times [.Num 2 ] [.Num 3 ]]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + (2 * 3)
    Plus (Num 1) (Times (Num 2) (Num 3))
\end{lstlisting}
%
\Tree [.Plus [.Num 1 ] [.Times [.Num 2 ] [.Num 3 ]]]

\begin{lstlisting}
Abstract Syntax Tree: (1 + 2) * 3
    Times (Plus (Num 1) (Num 2)) (Num 3)
\end{lstlisting}
%
\Tree [.Times [.Plus [.Num 1 ] [.Num 2 ]] [.Num 3 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + 2 * 3 + 4 * 5 + 6
    Plus (Plus (Plus (Num 1) (Times (Num 2) (Num 3))) (Times (Num 4) (Num 5))) (Num 6)
\end{lstlisting}
%
\Tree [.Plus [.Plus [.Plus [.Num 1 ] [.Times [.Num 2 ] [.Num 3 ]]] [.Times [.Num 4 ] [.Num 5 ]]] [.Num 6 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + 2 + 3
    Plus (Plus (Num 1) (Num 2)) (Num 3)
\end{lstlisting}
%
\Tree [.Plus [.Plus [.Num 1 ] [.Num 2 ]] [.Num 3 ]]

\begin{lstlisting}
Abstract Syntax Tree: (1 + 2) + 3
    Plus (Plus (Num 1) (Num 2)) (Num 3)
\end{lstlisting}
%
\Tree [.Plus [.Plus [.Num 1 ] [.Num 2 ]] [.Num 3 ]]

\begin{lstlisting}
Abstract Syntax Tree: 1 + (2 + 3)
    Plus (Num 1) (Plus (Num 2) (Num 3))
\end{lstlisting}
%
\Tree [.Plus [.Num 1 ] [.Plus [.Num 2 ] [.Num 3 ]]]

\begin{lstlisting}
The abstract syntax tree of 1+2+3 is identical to the one of (1+2)+3, but not the one of 1+(2+3).
\end{lstlisting}
%

\subsection{Week 5}

HW 5 - Syntax + Semantics of Lambda Calculus
Syntax
\begin{lstlisting}
x = EVar (Id "x")
\end{lstlisting}
%
\Tree [.EVar [.Id x ]]

\begin{lstlisting}
x x = EApp (EVar (Id "x") EVar (Id "x"))
\end{lstlisting}
%
\Tree [.EApp [.EVar [.Id x ]] [.EVar [.Id x ]]]

\begin{lstlisting}
x y = EApp (EVar (Id "x") EVar (Id "y"))
\end{lstlisting}
%
\Tree [.EApp [.EVar [.Id x ]] [.EVar [.Id y ]]]

\begin{lstlisting}
x y z = EApp (EVar (Id "x") EVar (Id "y")) EVar (Id "z"))
\end{lstlisting}
%
\Tree [.EApp [.EApp [.EVar [.Id x ]] [.EVar [.Id y ]]] [.EVar [.Id z ]]]

\begin{lstlisting}
\ x.x = Prog (EAbs(Id "x" EVar(Id "x")))
\end{lstlisting}
%
\Tree [.Prog [.EAbs [.Id x ] [.EVar [.Id x ]]]]

\begin{lstlisting}
(\x.x) x = Prog(EApp(EAbs(Id "x" EVar(Id "x")) EVar(Id "x")))
\end{lstlisting}
%
\Tree [.Prog [.EApp [.EAbs [.Id x ] [.EVar [.Id x ]]] [.EVar [.Id x ]]]]

\begin{lstlisting}
(\ x . (\ y . x y)) (\ x.x) z = Prog(EApp(EApp(EAbs(Id "x", EAbs(Id "y", EApp(EVar(Id "x"), EVar(Id "y")))), EAbs(Id "x", EVar(Id "x"))), EVar(Id "z")))
\end{lstlisting}
%
\Tree [.Prog [.EApp [.EApp [.EAbs [.Id x ] [.EAbs [.Id y ] [.EApp [.EVar [.Id x ]] [.EVar [.Id y ]]]]] [.EAbs [.Id x ] [.EVar [.Id x ]]]] [.EVar [.Id z ]]]]

\begin{lstlisting}
(\ x . \ y . x y z) a b c = Prog(EApp(EApp(EApp(EAbs(Id "x", EAbs(Id "y", EApp(EApp(EVar(Id "x"), EVar(Id "y")), EVar(Id "z")))), EVar(Id "a")), EVar(Id "b")), EVar(Id "c")))
\end{lstlisting}
%
\Tree  [.Prog [.EApp [.EApp [.EApp [.EAbs [.Id x ] [.EAbs [.Id y ] [.EApp [.EApp [.EVar [.Id x ]] [.EVar [.Id y ]]] [.EVar [.Id z ]]]]] [.EVar [.Id a ]]] [.EVar [.Id b ]]] [.EVar [.Id c ]]]]]

Semantics
\begin{lstlisting}
- Evaluate using pen-and-paper the following expressions:

(\x.x) a = a

\x.x a = \x.x a

(\x.\y.x) a b = (\y.a) b = a

(\x.\y.y) a b = (\y.y) b = b

(\x.\y.x) a b c = (\y.a) b c = a c

(\x.\y.y) a b c = (\y.y) b c = b c

(\x.\y.x) a (b c) = (\y.a) (b c) = a

(\x.\y.y) a (b c) = (\y.y) (b c) = b c

(\x.\y.x) (a b) c = (\y.a b) c = a b

(\x.\y.y) (a b) c = (\y.y) c = c

(\x.\y.x) (a b c) = \y.a b c

(\x.\y.y) (a b c) = \y.y
\end{lstlisting}
%

\begin{lstlisting}
- Evaluate (\x.x)((\y.y)a) by executing the function evalCBN

evalCBN(EApp (EAbs (Id "x") (EVar (Id "x"))) (EApp (EAbs (Id "y") (EVar (Id "y"))) (EVar (Id "a")))) = line 6
evalCBN (EApp (EAbs (Id "x") (EVar (Id "x"))) subst (Id "y") (EVar (Id "a")) (EVar (Id "y"))) = line 15
evalCBN (EApp (EAbs (Id "x") (EVar (Id "x"))) EVar (Id "a")) = line 6
evalCBN (subst (Id "x") (EVar (Id "a")) (EVar (Id "x"))) = line 15
evalCBN (EVar (Id "a")) = line 8
EVar (Id "a")
\end{lstlisting}
%

\subsection{Week 6}
Evaluate
\begin{lstlisting}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
=
((\m.\n. m n) (\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2))))
=
((.\n. (\f.\x. f (f x)) n)  (\f2.\x2. f2 (f2 (f2 x2))))
=
((\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2))))
=
((\x. (\f2.\x2. f2 (f2 (f2 x2))) ((\f3.\x3. f3 (f3 (f3 x3))) x)))
=
((\x. (\f2.\x2. f2 (f2 (f2 x2))) ((\x3. x (x (x x3))))))
=
(\x. (\x2. (\x3. x (x (x x3))) ((\x4. x5 (x5 (x5 x4))) ((\x6. x7 (x7 (x7 x6))) x2))))
=
(\x. (\x2. (\x3. x (x (x x3))) ((\x4. x5 (x5 (x5 x4))) (x7 (x7 (x7 x2))))))
=
(\x. (\x2. (x (x (x (x5 (x5 (x5 (x7 (x7 (x7 x2)))))))))))
=
\x. (\x2. (x (x (x (x5 (x5 (x5 (x7 (x7 (x7 x2))))))))))
\end{lstlisting}
%

\subsection{Week 7}
Explain whether each variable is bound or free - if it is bound, say the binder and scope of the variable.
\begin{lstlisting}
Lines 5-7
evalCBN (EApp e1 e2) = case (evalCBN e1) of
    (EAbs i e3) -> evalCBN (subst i e2 e3)
    e3 -> EApp e3 e2
\end{lstlisting}
%

\indent
e1 (line 5)
\begin{itemize}
  \item bound on the left of =
  \item scope is the end of line 7
\end{itemize}

\indent
e2 (line 5)
\begin{itemize}
  \item bound on the left of =
  \item scope is the end of line 7
\end{itemize}

\indent
i (line 6)
\begin{itemize}
  \item bound on the left of ->
  \item scope is the end of line 6
\end{itemize}

\indent
e3 (line 6)
\begin{itemize}
  \item bound on the left of ->
  \item scope is the end of line 6
\end{itemize}

\indent
e3 (line 7)
\begin{itemize}
  \item bound on the left of ->
  \item scope is the end of line 7
\end{itemize}

\indent
x (line 8)
\begin{itemize}
  \item bound on the left of =
  \item scope is the end of line 8
\end{itemize}


\begin{lstlisting}
Lines 18-22
subst id s (EAbs id1 e1) = 
    -- to avoid variable capture, we first substitute id1 with a fresh name inside the body of the lambda-abstraction, obtaining e2. Only then do we proceed to apply substitution of the original s for id in the body e2.
    let f = fresh (EAbs id1 e1)
        e2 = subst id1 (EVar f) e1 in 
        EAbs f (subst id s e2)
\end{lstlisting}
%

\indent
id (line 18)
\begin{itemize}
  \item bound on the left of =
  \item scope is to the end of line 22
\end{itemize}

\indent
s (line 18)
\begin{itemize}
  \item bound on the left of =
  \item scope is to the end of line 22
\end{itemize}

\indent
id1 (line 18)
\begin{itemize}
  \item bound on the left of =
  \item scope is to the end of line 22
\end{itemize}

\indent
e1 (line 18)
\begin{itemize}
  \item bound on the left of =
  \item scope is to the end of line 22
\end{itemize}

\indent
f (line 20)
\begin{itemize}
  \item bound on the left of =
  \item scope is to the end of line 22
\end{itemize}

\indent
e2 (line 21)
\begin{itemize}
  \item bound on the left of =
  \item scope is to the end of line 22
\end{itemize}

\begin{lstlisting}
- Evaluate (\x.\y.x) y z by executing the function evalCBN

evalCBN(EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "z")))) (EVar (Id "y")) (EVar (Id "z"))) = line 6
evalCBN (subst (Id "x") (EVar (Id "y")) (EVar (Id "x")) (EAbs (Id "y") (EVar (Id "x")))(EVar (Id "z"))) = line 15
evalCBN (EApp (EAbs (Id "y") (EVar (Id "y1"))) EVar (Id "z")) = line 6
evalCBN (subst (Id "y") (EVar (Id "z")) (EVar (Id "y1"))) = line 16
evalCBN (EVar (Id "y1")) = line 8
EVar (Id "y1")
\end{lstlisting}
%

Rewriting Introduction
\begin{lstlisting}
1. A = {}
---------
|       |
|       |
---------

- terminates - yes
- confluent - yes
- unique normal forms - yes


2. A = {a} and R = {}
---------
|   a   |
|       |
---------

- terminates - yes
- confluent - yes
- unique normal forms - yes


3. A = {a} and R = {(a,a)}
    
    ----->
    |    |
    a <---

- terminates - no
- confluent - yes
- unique normal forms - no


4. A = {a,b,c} and R = {(a,b),(a,c)}
    
        a
       / \
      /   \
     b     c

- terminates - yes
- confluent - no
- unique normal forms - no


5. A = {a,b} and R = {(a,a),(a,b)}
    
    ----->
    |    |
    a <---
    |
    b

- terminates - no
- confluent - yes
- unique normal forms - yes


6. A = {a,b,c} and R = {(a,b),(b,b),(a,c)}
    
        a
       / \
      /   \
  --> b    c
  |   |
  <----

- terminates - no
- confluent - no
- unique normal forms - no


7. A = {a,b,c} and R = {(a,b),(b,b),(a,c),(c,c)}
    
        a
       / \
      /   \
  --> b    c -->
  |   |    |   |
  <----    <----

- terminates - no
- confluent - no
- unique normal forms - no

\end{lstlisting}
%

Find an example of an ARS for each of the possible 8 combinations - draw pictures.


\begin{lstlisting}
1. confluent, terminating, has unique normal forms
    A = {a,b} and R = {(a,b)}
        a
        |
        b

2. confluent, terminating, doesn't have unique normal forms

    - not possible

3. confluent, not terminating, has unique normal forms

    A = {a,b} and R = {(a,a),(a,b)}
        
        ----->
        |    |
        a <---
        |
        b

4. confluent, not terminating, doesn't have unique normal forms

       A = {a,b,c} and R = {(a,b),(a,c),(b,a),(c,a)}
        
        --> a <--
        |  / \  |
        | /   \ |
        b       c

5. not confluent, terminating, has unique normal forms

    - not possible

6. not confluent, terminating, doesn't have unique normal forms

    A = {a,b,c} and R = {(a,b),(a,c)}
        
            a
           / \
          /   \
         b     c

7. not confluent, not terminating, has unique normal forms

    - not possible

8. not confluent, not terminating, doesn't have unique normal forms

    A = {a,b,c} and R = {(a,b),(b,b),(a,c)}
        
            a
           / \
          /   \
      --> b    c
      |   |
      <----


\end{lstlisting}
%

\subsection{Week 8}
Answer the questions about the rewrite system

\begin{lstlisting}
  aa -> a
  bb -> b
  ba -> ab
  ab -> ba

Why does the ARS not terminate?
    The ARS doesn't terminate because the two rules ba -> ab and ab -> ba are circular.

What are the normal forms?
    The normal forms are a, b

Can you change the rules so that the new ARS has unique normal forms (but still has the same equivalence relation)?
    aa -> a
    bb -> b
    ba -> ab
    ab -> ba
    b -> a

What do the normal forms mean? Describe the function implemented by the ARS.
    The normal forms mean that at that point, nothing can be reduced further. The ARS takes a string consisting of a's and b's. If there are doubles (ie aa or bb), then the length of those doubles is reduced. In the case of ba or ab, then the letters are flipped.

\end{lstlisting}
%

\subsection{Week 9}
\begin{lstlisting}
Consider the ARS (A,->) where A is the set of words over the alphabet {a,b,c} and -> is defined via the following schema of rules.

ba -> ab
ab -> ba
ac -> ca
ca -> ac
bc -> cb
cb -> bc
 
aa -> b
ab -> c
ac ->  
bb -> 
cb -> a
cc -> b

The upper section of the ARS (involving ba, ab, ac, ca, bc, cb) is circular. There is a possibility that words could be arranged in a way to allow the lower section to come into play. If ba -> ab and to the right is another ba, then we would have abba. Then using bb -> , the resulting form could potentially be aa, then b. However, it is unknown if this would ever be the case, as another possibility is that abba becomes abab or baba. Additionally, ab reduces both to ba and also c, adding yet another possibility. 


\end{lstlisting}

\subsection{Week 10}
Activity and Homework: 
\newline\indent
Let F be $\lambda$f.$\lambda$n. if n==0 then 1 else f(n-1)*n and reduce fixF2.
\newline\indent
fixF $\approx$ FfixF (computation rule)

\begin{lstlisting}
fixF 2 = FfixF 2 = if 2 == 0 then 1 else fixF (2-1)*2  --> assume we have a function for 2-1
                   = (fixF 1) * 2
                   = (FfixF 1 = if 1 == 0 then 1 else fixF (1-1) * 1) * 2
                                = (fixF 0) * 2
                                = (FfixF 0 if 0 == 0 then 1) * 2
                                = 1 * 2
                                = 2
               
\end{lstlisting}

\subsection{Week 11}
Discussion Question:
\begin{lstlisting}
In section 4.5, the paper states that contracts can only be valued over observables that we can model. Is there a case where this is untrue? 
\end{lstlisting}

Discussion Responses:
\begin{lstlisting}
Question 1: To further the question of how a software system built on this technology would take into account human behavior, legal requirements, security, etc. what are the limits of this language's applications? How difficult would it be to account for these limitations and would this language still be worth using to generate contracts given the limits and ease of addressing them?

Response: I think that the language presented in the paper is able to define and generate lots of broad or general contracts, but there is definitely a limit when taking things into account like legality and security. I'm not even sure how it would begin to approach something like human behavior. While I think that the language as it is now is usable to an extent, I think there would definitely need to be additions made to the language in order for it to continue to be worth using in the future. The difficult thing is how to find out what additions need to be made, and how to represent intangible or unpredictable things such as human behavior.


Question: With any consumer-facing software or program, its success ultimately relies on how well it is adopted by its target audience. While composing contracts and its use of combinators can have potentially huge benefits, what are some ways we can make it user-friendly and encouraging for financial experts to use this new method?

Response: I agree with Eli that visual scripting or drag/drop implementation would make things much simpler for users to understand. The idea and usage of combinators could be intimidating at first glance for people unfamiliar with the terminology or with programming, but I think drag/drop would definitely help users (whether first timers or more experienced users) feel more at ease with using the program.
\end{lstlisting}

\subsection{Week 12}
\textbf{Hoare Logic}
\newline Apply the method of analysis from the lecture to
\begin{lstlisting}
    while (x!=0) do z:=z*y; x:= x-1 done
\end{lstlisting}

\noindent\textbf{What is the invariant? Indicate the reasoning steps in which you apply the rules of Hoare logic.}\newline

\textbf{Pre and post conditions:}
\newline $\{x \geq 0\}$  while (x!=0) do  z:=z*y; x:= x-1 done $\{post\}$ \newline
\textbf{Table of execution:}
\newline Where t is the number of times the loop executes, and assume program variables are as follows: x=5, y=2, z=2.
\begin{center}
\begin{tabular}{ c c c c }
 t & x & y & z \\ 
 0 & 5 & 2 & 2 \\  
 1 & 4 & 2 & 4 \\
 2 & 3 & 2 & 8 \\
 3 & 2 & 2 & 16 \\
 4 & 1 & 2 & 32 \\
 5 & 0 & 2 & 64 
\end{tabular}
\end{center}
The above numbers satisfy the following invariants:
\[t + x = 5\]
\[z = y^t * 2\]
\[z = y^{x-5} * 2\]

However, this is only the case for the number and table above. To make this more general, we must store the original values of x, y, and z for calculations. To do so, let x = n, y = k, z = m.
\[z = k^n * m \] 

This gives us 
\[\{x=n \wedge z=m \wedge y=k\} \quad while \quad (x!=0) do \quad z:=z*y; \quad x:= x-1 \quad done \quad \{z=n+m*k\}\]
 
\section{Project}

This section details the project.

\subsection{Specification}
For this project, I plan to learn a combination of HTML and css to build a website. 

\subsection{Milestones}
\textbf{Milestone 1 (11/28):} 
\newline\indent
The first milestone due date is 11/28. It will consist of a short writeup on the history of html/css and why these languages are so widely used when building websites or webpages. Just what about these languages makes it ideal to use for this purpose, and what benefits are there compared to other languages? Additional questions like what influenced the development choices behind the making of these languages will also be considered in this milestone.\newline

\noindent\textbf{Milestone 2 (12/2):}
\newline\indent
The second milestone due date is 11/30. This milestone will consist of a more fleshed out description and design of how the website will look and what it will contain. A clear plan of what needs to be implemented and the steps that need to be taken will be finalized. At this point, code will also be mailed to the professor for a progress check and possible feedback.\newline

\noindent\textbf{Milestone 3 (12/7):}
\newline\indent
The third milestone due date is 12/7. This milestone will contain updated progress on the website. Additionally, it will include the beginnings of a synthesis on the process of learning html/css. This will be a commentary on my thoughts as I learned these languages, as well as things I wish I had learned sooner during the process. The ultimate goal is to try to put my learning process into words so that I can apply better learning techniques when I pick up new languages in the future.

\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

(approx 400 words)

In the conclusion, I want a critical reflection on the content of the course. Step back from the technical details. How does the course fit into the wider world of programming languages and software engineering?

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\bibitem[P]{P} \href{https://tex.stackexchange.com/questions/2369/why-do-the-less-than-symbol-and-the-greater-than-symbol-appear-wrong-as}{Punctuation}, StackExchange, 2022.
\bibitem[S]{S} \href{https://tex.stackexchange.com/questions/14526/spaces-behind-textgreater-not-working-as-expected}{Spacing}, StackExchange, 2022.
\bibitem[T]{T} \href{http://sznfong.scripts.mit.edu/site/wp-content/uploads/2018/03/treedrawingtutorialv2.pdf}{Trees}, Massachusetts Institute of Technology, 2022.
\end{thebibliography}

\end{document}